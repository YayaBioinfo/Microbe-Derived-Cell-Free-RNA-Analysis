## ğŸ§¬ Data Normalization

This section describes the workflow used to process **Kraken2 report files**, generate a species/genus-level count matrix for **Bacteria**, and perform normalization and batch correction using **edgeR (TMM)** and **RUVSeq (RUVg)**.

---

## 1ï¸âƒ£ Generate Bacterial Species Count Matrix from Kraken2 Reports

### ğŸ“Œ Description
All `*_report.txt` files generated by Kraken2 are parsed to extract **species-level taxa** under the **Bacteria** domain. The output is a merged count matrix where rows represent species and columns represent samples.

### ğŸ§ª Steps
- Read all Kraken2 report files
- Identify the Bacteria domain
- Extract species-level (`rank == "S"`) taxa
- Merge counts across samples
- Replace missing values with zero

### ğŸ“„ Output
- `kraken2_species_counts_Bacteria.csv`

### ğŸ’» R Script
```r
# Set working directory
setwd("C:/Users/yayai/Downloads/kraken")

# List all Kraken2 report files
files <- list.files(pattern = "_report\\.txt$")

# Function to extract species-level counts under Bacteria
read_kraken_report <- function(file) {
  df <- read.table(file, sep = "\t", header = FALSE, quote = "",
                   fill = TRUE, comment.char = "")
  colnames(df) <- c("percent", "reads_clade", "reads_direct",
                    "rank", "ncbi_id", "name")

  bacteria_start <- which(df$name == "Bacteria" &
                          df$rank %in% c("R", "D", "K"))

  if (length(bacteria_start) > 0) {
    df <- df[bacteria_start:nrow(df), ]
  }

  species_df <- df %>%
    dplyr::filter(rank == "S" & reads_direct > 0) %>%
    dplyr::select(name, reads_direct)

  sample_name <- tools::file_path_sans_ext(basename(file))
  colnames(species_df)[2] <- sample_name

  return(species_df)
}

list_of_dfs <- lapply(files, read_kraken_report)

counts <- Reduce(function(x, y) dplyr::full_join(x, y, by = "name"),
                 list_of_dfs)

counts[is.na(counts)] <- 0
rownames(counts) <- counts$name
counts$name <- NULL

write.csv(counts, "kraken2_species_counts_Bacteria.csv")
````

---

## 2ï¸âƒ£ Filtering, Metadata Alignment, and TMM Normalization

### ğŸ“Œ Description

The count matrix is filtered based on abundance, aligned with metadata, and normalized using **TMM normalization** implemented in **edgeR**.

### ğŸ§ª Steps

* Load count matrix and metadata
* Match sample names
* Filter taxa with median count > 10
* Perform TMM normalization

### ğŸ“„ Output

* `kraken2_genus_counts_TMM.csv`

### ğŸ’» R Script

```r
library(edgeR)
library(dplyr)
library(readr)

counts <- read.csv("kraken2_genus_counts_Bacteria.csv",
                   row.names = 1, check.names = FALSE)

colnames(counts) <- sub("_report$", "", colnames(counts))

metadata <- read.delim("metadatamcfrna.txt", header = TRUE,
                       stringsAsFactors = FALSE)

metadata$cfRNA_Label <- trimws(metadata$cfRNA_Label)
counts <- counts[, trimws(colnames(counts))]

intersect_samples <- intersect(colnames(counts),
                               metadata$cfRNA_Label)

counts_filtered <- counts[, intersect_samples]
metadata <- metadata[match(colnames(counts_filtered),
                            metadata$cfRNA_Label), ]

stopifnot(all(colnames(counts_filtered) ==
              metadata$cfRNA_Label))

keep <- apply(counts_filtered, 1,
              function(x) median(x) > 10)

counts_filtered <- counts_filtered[keep, ]

dge <- DGEList(counts = counts_filtered)
dge <- calcNormFactors(dge, method = "TMM")
tmm <- cpm(dge, normalized.lib.sizes = TRUE)

write.csv(tmm, "kraken2_genus_counts_TMM.csv")
```

---

## 3ï¸âƒ£ Removal of Unwanted Variation Using RUVg

### ğŸ“Œ Description

To account for technical variation and batch effects, **RUVg** is applied using the **25% most stable taxa** as empirical control features.

### ğŸ§ª Steps

* Identify low-variance taxa
* Apply RUVg correction (k = 1)
* Export RUV factors and normalized counts

### ğŸ“„ Output

* `RUV_W_factors_global.csv`
* `RUV_normalized_counts_global.csv`

### ğŸ’» R Script

```r
library(RUVSeq)

counts <- read.csv("kraken2_genus_counts_TMM.csv",
                   row.names = 1, check.names = FALSE)

metadata <- read.delim("metadatamcfrna.txt", header = TRUE)
metadata <- metadata %>%
  dplyr::filter(cfRNA_Label %in% colnames(counts))

counts <- counts[, metadata$cfRNA_Label]

gene_var <- apply(counts, 1, var)
control_genes <- names(sort(gene_var))[
  1:floor(length(gene_var) * 0.25)
]

set <- newSeqExpressionSet(as.matrix(counts),
  phenoData = data.frame(metadata,
  row.names = metadata$cfRNA_Label)
)

set_ruv <- RUVg(set, control_genes, k = 1)

write.csv(
  pData(set_ruv)[, grepl("^W_", colnames(pData(set_ruv)))],
  "RUV_W_factors_global.csv"
)

write.csv(
  exprs(set_ruv),
  "RUV_normalized_counts_global.csv"
)
```


